// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ViewPortCulling


uint instanceCount;
AppendStructuredBuffer<float4x4> cullresult;
StructuredBuffer<float4x4> input;
float4 planes[6];
float3 boxMaxMin[2];

bool isOutSide(float4 plane, float3 position){
	float result = dot(plane.xyz, position) + plane.w;
	if(result > 0){
		return true;
	}
	return false;
}

[numthreads(640,1,1)]
void ViewPortCulling (uint3 id : SV_DispatchThreadID)
{
	uint index = id.x;
	if(index >= instanceCount)
	{
		return;
	}
	float4x4 positionInfo = input[index];
	//如何得到包围盒
	//float3 boxMax = boxMaxMin[0];
	//float3 boxMin = boxMaxMin[0];
	float3 boxMin = float3(-1.5, 0, -1.5);
    float3 boxMax = float3(1.5, 7, 1.5);
	float4 boundVerts[8];//AABB8个顶点坐标
	boundVerts[0] = mul(positionInfo, float4(boxMax, 1.0));
	boundVerts[1] = mul(positionInfo, float4(boxMin, 1.0));
	boundVerts[2] = mul(positionInfo, float4(boxMin.x, boxMin.y, boxMax.z, 1.0));
	boundVerts[3] = mul(positionInfo, float4(boxMin.x, boxMax.y, boxMin.z, 1.0));
	boundVerts[4] = mul(positionInfo, float4(boxMin.x, boxMax.y, boxMax.z, 1.0));

	boundVerts[5] = mul(positionInfo, float4(boxMax.x, boxMin.y, boxMax.z, 1.0));
	boundVerts[6] = mul(positionInfo, float4(boxMax.x, boxMax.y, boxMin.z, 1.0));
	boundVerts[7] = mul(positionInfo, float4(boxMax.x, boxMin.y, boxMin.z, 1.0));

	for(int i=0;i<6;i++){
		for(int j=0;j<8;j++){

			if(!isOutSide(planes[i], boundVerts[j].xyz)){
				break;
			}
			if(j == 7){
				return;
			}

		}
	}
	cullresult.Append(positionInfo);

}
